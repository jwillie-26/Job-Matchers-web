"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.helper = helper;

var t = _interopRequireWildcard(require("@babel/types"));

var _helperModuleImports = require("@babel/helper-module-imports");

var _helperAnnotateAsPure = _interopRequireDefault(require("@babel/helper-annotate-as-pure"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};

function helper(babel, options) {
  const FILE_NAME_VAR = "_jsxFileName";
  const JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
  const JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
  const JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
  const JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;
  const IMPORT_NAME_SIZE = options.development ? 3 : 4;
  const {
    importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,
    runtime: RUNTIME_DEFAULT = DEFAULT.runtime,
    pragma: PRAGMA_DEFAULT = DEFAULT.pragma,
    pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag
  } = options;
  const injectMetaPropertiesVisitor = {
    JSXOpeningElement(path, state) {
      for (const attr of path.get("attributes")) {
        if (!attr.isJSXElement()) continue;
        const {
          name
        } = attr.node.name;

        if (name === "__source" || name === "__self") {
          throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);
        }
      }

      const source = t.jsxAttribute(t.jsxIdentifier("__source"), t.jsxExpressionContainer(makeSource(path, state)));
      const self = t.jsxAttribute(t.jsxIdentifier("__self"), t.jsxExpressionContainer(t.thisExpression()));
      path.pushContainer("attributes", [source, self]);
    }

  };
  return {
    JSXNamespacedName(path, state) {
      const throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;

      if (throwIfNamespace) {
        throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \
You can set \`throwIfNamespace: false\` to bypass this warning.`);
      }
    },

    JSXSpreadChild(path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    },

    JSXElement: {
      exit(path, file) {
        let callExpr;

        if (file.get("@babel/plugin-react-jsx/runtime") === "classic" || shouldUseCreateElement(path)) {
          callExpr = buildCreateElementCall(path, file);
        } else {
          callExpr = buildJSXElementCall(path, file);
        }

        path.replaceWith(t.inherits(callExpr, path.node));
      }

    },
    JSXFragment: {
      exit(path, file) {
        let callExpr;

        if (file.get("@babel/plugin-react-jsx/runtime") === "classic") {
          callExpr = buildCreateElementFragmentCall(path, file);
        } else {
          callExpr = buildJSXFragmentCall(path, file);
        }

        path.replaceWith(t.inherits(callExpr, path.node));
      }

    },

    JSXAttribute(path) {
      if (t.isJSXElement(path.node.value)) {
        path.node.value = t.jsxExpressionContainer(path.node.value);
      }
    },

    Program: {
      enter(path, state) {
        if (hasJSX(path)) {
          const {
            file
          } = state;
          let runtime = RUNTIME_DEFAULT;
          let source = IMPORT_SOURCE_DEFAULT;
          let sourceSet = !!options.importSource;
          let pragma = PRAGMA_DEFAULT;
          let pragmaFrag = PRAGMA_FRAG_DEFAULT;
          let pragmaSet = !!options.pragma;
          let pragmaFragSet = !!options.pragmaFrag;

          if (file.ast.comments) {
            for (const comment of file.ast.comments) {
              const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

              if (sourceMatches) {
                source = sourceMatches[1];
                sourceSet = true;
              }

              const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

              if (runtimeMatches) {
                runtime = runtimeMatches[1];
              }

              const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

              if (jsxMatches) {
                pragma = jsxMatches[1];
                pragmaSet = true;
              }

              const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

              if (jsxFragMatches) {
                pragmaFrag = jsxFragMatches[1];
                pragmaFragSet = true;
              }
            }
          }

          state.set("@babel/plugin-react-jsx/runtime", runtime);

          if (runtime === "classic") {
            if (sourceSet) {
              throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);
            }

            state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(pragma));
            state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(pragmaFrag));
            state.set("@babel/plugin-react-jsx/usedFragment", false);
            state.set("@babel/plugin-react-jsx/pragmaSet", pragma !== DEFAULT.pragma);
            state.set("@babel/plugin-react-jsx/pragmaFragSet", pragmaFrag !== DEFAULT.pragmaFrag);
          } else if (runtime === "automatic") {
            if (pragmaSet || pragmaFragSet) {
              throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);
            }

            const importName = addAutoImports(path, Object.assign({}, state.opts, {
              source
            }));
            state.set("@babel/plugin-react-jsx/jsxIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsx", importName)));
            state.set("@babel/plugin-react-jsx/jsxStaticIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsxs", importName)));
            state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(createIdentifierName(path, "createElement", importName)));
            state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(createIdentifierName(path, "Fragment", importName)));
            state.set("@babel/plugin-react-jsx/importSourceSet", source !== DEFAULT.importSource);
          } else {
            throw path.buildCodeFrameError(`Runtime must be either "classic" or "automatic".`);
          }

          if (options.development) {
            path.traverse(injectMetaPropertiesVisitor, state);
          }
        }
      },

      exit(path, state) {
        if (state.get("@babel/plugin-react-jsx/runtime") === "classic" && state.get("@babel/plugin-react-jsx/pragmaSet") && state.get("@babel/plugin-react-jsx/usedFragment") && !state.get("@babel/plugin-react-jsx/pragmaFragSet")) {
          throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
        }
      }

    }
  };

  function shouldUseCreateElement(path) {
    const openingPath = path.get("openingElement");
    const attributes = openingPath.node.attributes;
    let seenPropsSpread = false;

    for (let i = 0; i < attributes.length; i++) {
      const attr = attributes[i];

      if (seenPropsSpread && t.isJSXAttribute(attr) && attr.name.name === "key") {
        return true;
      } else if (t.isJSXSpreadAttribute(attr)) {
        seenPropsSpread = true;
      }
    }

    return false;
  }

  function createIdentifierName(path, name, importName) {
    if ((0, _helperModuleImports.isModule)(path)) {
      const identifierName = `${importName[name]}`;
      return identifierName;
    } else {
      return `${importName[name]}.${name}`;
    }
  }

  function getImportNames(parentPath) {
    const imports = new Set();
    parentPath.traverse({
      "JSXElement|JSXFragment"(path) {
        if (path.type === "JSXFragment") imports.add("Fragment");
        const openingPath = path.get("openingElement");
        const validChildren = t.react.buildChildren(openingPath.parent);
        let importName;

        if (path.type === "JSXElement" && shouldUseCreateElement(path)) {
          importName = "createElement";
        } else if (options.development) {
          importName = "jsxDEV";
        } else if (validChildren.length > 1) {
          importName = "jsxs";
        } else {
          importName = "jsx";
        }

        imports.add(importName);

        if (imports.size === IMPORT_NAME_SIZE) {
          path.stop();
        }
      }

    });
    return imports;
  }

  function hasJSX(parentPath) {
    let fileHasJSX = false;
    parentPath.traverse({
      "JSXElement|JSXFragment"(path) {
        fileHasJSX = true;
        path.stop();
      }

    });
    return fileHasJSX;
  }

  function getSource(source, importName) {
    switch (importName) {
      case "Fragment":
        return `${source}/${options.development ? "jsx-dev-runtime" : "jsx-runtime"}`;

      case "jsxDEV":
        return `${source}/jsx-dev-runtime`;

      case "jsx":
      case "jsxs":
        return `${source}/jsx-runtime`;

      case "createElement":
        return source;
    }
  }

  function addAutoImports(path, state) {
    const imports = getImportNames(path, state);

    if ((0, _helperModuleImports.isModule)(path)) {
      const importMap = {};
      imports.forEach(importName => {
        if (!importMap[importName]) {
          importMap[importName] = (0, _helperModuleImports.addNamed)(path, importName, getSource(state.source, importName), {
            importedInterop: "uncompiled",
            ensureLiveReference: true
          }).name;
        }
      });
      return importMap;
    } else {
      const importMap = {};
      const sourceMap = {};
      imports.forEach(importName => {
        const source = getSource(state.source, importName);

        if (!importMap[importName]) {
          if (!sourceMap[source]) {
            sourceMap[source] = (0, _helperModuleImports.addNamespace)(path, source, {
              importedInterop: "uncompiled",
              ensureLiveReference: true
            }).name;
          }

          importMap[importName] = sourceMap[source];
        }
      });
      return importMap;
    }
  }

  function createIdentifierParser(id) {
    return () => {
      return id.split(".").map(name => t.identifier(name)).reduce((object, property) => t.memberExpression(object, property));
    };
  }

  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
    const fileLineLiteral = lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();
    const fileColumnLiteral = column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();
    const fileNameProperty = t.objectProperty(t.identifier("fileName"), fileNameIdentifier);
    const lineNumberProperty = t.objectProperty(t.identifier("lineNumber"), fileLineLiteral);
    const columnNumberProperty = t.objectProperty(t.identifier("columnNumber"), fileColumnLiteral);
    return t.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
  }

  function makeSource(path, state) {
    const location = path.node.loc;

    if (!location) {
      return path.scope.buildUndefinedNode();
    }

    if (!state.fileNameIdentifier) {
      const {
        filename = ""
      } = state;
      const fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
      const scope = path.hub.getScope();

      if (scope) {
        scope.push({
          id: fileNameIdentifier,
          init: t.stringLiteral(filename)
        });
      }

      state.fileNameIdentifier = fileNameIdentifier;
    }

    return makeTrace(t.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
  }

  function convertJSXIdentifier(node, parent) {
    if (t.isJSXIdentifier(node)) {
      if (node.name === "this" && t.isReferenced(node, parent)) {
        return t.thisExpression();
      } else if (t.isValidIdentifier(node.name, false)) {
        node.type = "Identifier";
      } else {
        return t.stringLiteral(node.name);
      }
    } else if (t.isJSXMemberExpression(node)) {
      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
    } else if (t.isJSXNamespacedName(node)) {
      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);
    }

    return node;
  }

  function convertAttributeValue(node) {
    if (t.isJSXExpressionContainer(node)) {
      return node.expression;
    } else {
      return node;
    }
  }

  function convertAttribute(node) {
    const value = convertAttributeValue(node.val