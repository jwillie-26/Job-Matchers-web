this.workbox = this.workbox || {};
this.workbox.backgroundSync = (function (exports, WorkboxError_mjs, logger_mjs, assert_mjs, getFriendlyURL_mjs, DBWrapper_mjs) {
  'use strict';

  try {
    self['workbox:background-sync:4.3.1'] && _();
  } catch (e) {} // eslint-disable-line

  /*
    Copyright 2018 Google LLC

    Use of this source code is governed by an MIT-style
    license that can be found in the LICENSE file or at
    https://opensource.org/licenses/MIT.
  */
  const DB_VERSION = 3;
  const DB_NAME = 'workbox-background-sync';
  const OBJECT_STORE_NAME = 'requests';
  const INDEXED_PROP = 'queueName';
  /**
   * A class to manage storing requests from a Queue in IndexedbDB,
   * indexed by their queue name for easier access.
   *
   * @private
   */

  class QueueStore {
    /**
     * Associates this instance with a Queue instance, so entries added can be
     * identified by their queue name.
     *
     * @param {string} queueName
     * @private
     */
    constructor(queueName) {
      this._queueName = queueName;
      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, DB_VERSION, {
        onupgradeneeded: this._upgradeDb
      });
    }
    /**
     * Append an entry last in the queue.
     *
     * @param {Object} entry
     * @param {Object} entry.requestData
     * @param {number} [entry.timestamp]
     * @param {Object} [entry.metadata]
     * @private
     */


    async pushEntry(entry) {
      {
        assert_mjs.assert.isType(entry, 'object', {
          moduleName: 'workbox-background-sync',
          className: 'QueueStore',
          funcName: 'pushEntry',
          paramName: 'entry'
        });
        assert_mjs.assert.isType(entry.requestData, 'object', {
          moduleName: 'workbox-background-sync',
          className: 'QueueStore',
          funcName: 'pushEntry',
          paramName: 'entry.requestData'
        });
      } // Don't specify an ID since one is automatically generated.


      delete entry.id;
      entry.queueName = this._queueName;
      await this._db.add(OBJECT_STORE_NAME, entry);
    }
    /**
     * Preppend an entry first in the queue.
     *
     * @param {Object} entry
     * @param {Object} entry.requestData
     * @param {number} [entry.timestamp]
     * @param {Object} [entry.metadata]
     * @private
     */


    async unshiftEntry(entry) {
      {
        assert_mjs.assert.isType(entry, 'object', {
          moduleName: 'workbox-background-sync',
          className: 'QueueStore',
          funcName: 'unshiftEntry',
          paramName: 'entry'
        });
        assert_mjs.assert.isType(entry.requestData, 'object', {
          moduleName: 'workbox-background-sync',
          className: 'QueueStore',
          funcName: 'unshiftEntry',
          paramName: 'entry.requestData'
        });
      }

      const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
        count: 1
      });

      if (firstEntry) {
        // Pick an ID one less than the lowest ID in the object store.
        entry.id = firstEntry.id - 1;
      } else {
        // Otherwise let the auto-incrementor assign the ID.
        delete entry.id;
      }

      entry.queueName = this._queueName;
      await this._db.add(OBJECT_STORE_NAME, entry);
    }
    /**
     * Removes and returns the last entry in the queue matching the `queueName`.
     *
     * @return {Promise<Object>}
     * @private
     */


    async popEntry() {
      return this._removeEntry({
        direction: 'prev'
      });
    }
    /**
     * Removes and returns the first entry in the queue matching the `queueName`.
     *
     * @return {Promise<Object>}
     * @private
     */


    async shiftEntry() {
      return this._removeEntry({
        direction: 'next'
      });
    }
    /**
     * Returns all entries in the store matching the `queueName`.
     *
     * @param {Object} options See workbox.backgroundSync.Queue~getAll}
     * @return {Promise<Array<Object>>}
     * @private
     */


    async getAll() {
      return await this._db.getAllMatching(OBJECT_STORE_NAME, {
        index: INDEXED_PROP,
        query: IDBKeyRange.only(this._queueName)
      });
    }
    /**
     * Deletes the entry for the given ID.
     *
     * WARNING: this method does not ensure the deleted enry belongs to this
     * queue (i.e. matches the `queueName`). But this limitation is acceptable
     * as this class is not publicly exposed. An additional check would make
     * this method slower than it needs to be.
     *
     * @private
     * @param {number} id
     */


    async deleteEntry(id) {
      await this._db.delete(OBJECT_STORE_NAME, id);
    }
    /**
     * Removes and returns the first or last entry in the queue (based on the
     * `direction` argument) matching the `queueName`.
     *
     * @return {Promise<Object>}
     * @private
     */


    async _removeEntry({
      direction
    }) {
      const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
        direction,
        index: INDEXED_PROP,
        query: IDBKeyRange.only(this._queueName),
        count: 1
      });

      if (entry) {
        await this.deleteEntry(entry.id);
        return entry;
      }
    }
    /**
     * Upgrades the database given an `upgradeneeded` event.
     *
     * @param {Event} event
     * @private
     */


    _upgradeDb(event) {
      const db = event.target.result;

      if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {
        if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {
          db.deleteObjectStore(OBJECT_STORE_NAME);
        }
      }

      const objStore = db.createObjectStore(OBJECT_STORE_NAME, {
        autoIncrement: true,
        keyPath: 'id'
      });
      objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {
        unique: false
      });
    }

  }

  /*
    Copyright 2018 Google LLC

    Use of this source code is governed by an MIT-style
    license that can be found in the LICENSE file or at
    https://opensource.org/licenses/MIT.
  */
  const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];
  /**
   * A class to make it easier to serialize and de-serialize requests so they
   * can be stored in IndexedDB.
   *
   * @private
   */

  class StorableRequest {
    /**
     * Converts a Request object to a plain object that can be structured
     * cloned or JSON-stringified.
     *
     * @param {Request} request
     * @return {Promise<StorableRequest>}
     *
     * @private
     */
    static async fromRequest(request) {
      const requestData = {
        url: request.url,
        headers: {}
      }; // Set the body if present.

      if (request.method !== 'GET') {
        // Use ArrayBuffer to support non-text request bodies.
        // NOTE: we can't use Blobs becuse Safari doesn't support storing
        // Blobs in IndexedDB in some cases:
        // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457
        requestData.body = await request.clone().arrayBuffer();
      } // Convert the headers from an iterable to an object.


      for (const [key, value] of request.headers.entries()) {
        requestData.headers[key] = value;
      } // Add all other serializable request properties


      for (const prop of serializableProperties) {
        if (request[prop] !== undefined) {
          requestData[prop] = request[prop];
        }
      }

      return new StorableRequest(requestData);
    }
    /**
     * Accepts an object of request data that can be used to construct a
     * `Request` but can also be stored in IndexedDB.
     *
     * @param {Object} requestData An object of request data that includes the
     *     `url` plus any relevant properties of
     *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.
     * @private
     */


    constructor(requestData) {
      {
        assert_mjs.assert.isType(requestData, 'object', {
          moduleName: 'workbox-background-sync',
          className: 'StorableRequest',
          funcName: 'constructor',
          paramName: 'requestData'
        });
        assert_mjs.assert.isType(requestData.url, 'string', {
          moduleName: 'workbox-background-sync',
          className: 'StorableRequest',
          funcName: 'constructor',
          paramName: 'requestData.url'
        });
      } // If the request's mode is `navigate`, convert it to `same-origin` since
      // navigation requests can't be constructed via script.


      if (requestData.mode === 'navigate') {
        requestData.mode = 'same-origin';
      }

      this._requestData = requestData;
    }
    /**
     * Returns a deep clone of the instances `_requestData` object.
     *
     * @return {Object}
     *
     * @private
     */


    toObject() {
      const requestData = Object.assign({}, this._requestData);
      requestData.headers = Object.assign({}, this._requestData.headers);

      if (requestData.body) {
        requestData.body = requestData.body.slice(0);
      }

      return requestData;
    }
    /**
     * Converts this instance to a Request.
     *
     * @return {Request}
     *
     * @private
     */


    toRequest() {
      return new Request(this._requestData.url, this._requestData);
    }
    /**
     * Creates and returns a deep clone of the instance.
     *
     * @return {StorableRequest}
     *
     * @private
     */


    clone() {
      return new StorableRequest(this.toObject());
    }

  }

  /*
    Copyright 2018 Google LLC

    Use of this source code is governed by an MIT-style
    license that can be found in the LICENSE file or at
    https://opensource.org/licenses/MIT.
  */
  const TAG_PREFIX = 'workbox-background-sync';
  const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes

  const queueNames = new Set();
  /**
   * A class to manage storing failed requests in IndexedDB and retrying them
   * later. All parts of the storing and replaying process are observable via
   * callbacks.
   *
   * @memberof workbox.backgroundSync
   */

  class Queue {
    /**
     * Creates an instance of Queue with the given options
     *
     * @param {string} name The unique name for this q